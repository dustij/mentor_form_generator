import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../providers/providers.dart';

// Create a single, reusable TextFormField widget that “knows” how to:
//    - watch the current String value
//    - call setValue(...) on the notifier when onChanged fires
//
// We make it generic by saying “NotifierT extends StringNotifier”.
// Its corresponding provider type is then AutoDisposeNotifierProvider<String>.

class ConsumerTextFormField<NotifierT extends StringNotifier>
    extends ConsumerWidget {
  // provider was generated by @riverpod
  final AutoDisposeNotifierProvider<NotifierT, String> provider;
  final String labelText;
  final String hintText;
  final FormFieldValidator<String>? validator;
  final TextInputType keyboardType;
  final int maxLines;
  final int? maxLength;
  final bool? isRequired;

  const ConsumerTextFormField({
    super.key,
    required this.provider,
    required this.labelText,
    this.validator,
    this.keyboardType = TextInputType.text,
    this.maxLines = 1,
    this.hintText = '',
    this.maxLength,
    this.isRequired = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentValue = ref.watch(provider);

    return TextFormField(
      initialValue: currentValue,
      decoration: InputDecoration(
        border: const OutlineInputBorder(),
        label: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(labelText),
            if (isRequired ?? false)
              const Text(' *', style: TextStyle(color: Colors.red)),
          ],
        ),
        hintText: hintText,
      ),
      keyboardType: keyboardType,
      maxLines: maxLines,
      maxLengthEnforcement: maxLength != null
          ? MaxLengthEnforcement.enforced
          : null,
      maxLength: maxLength,
      validator: validator,
      onChanged: (newText) {
        ref.read(provider.notifier).setValue(newText);
      },
    );
  }
}
