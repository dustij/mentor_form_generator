/// Defines a generic `ConsumerTextFormField` widget that binds a text input field
/// to a Riverpod `StringNotifier`.
///
/// This widget listens to the provider's current value and updates it via `onChanged`,
/// allowing easy integration of form state management using Riverpod.
library;

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'package:hooks_riverpod/hooks_riverpod.dart';

import '../providers/providers.dart';

/// A reusable text form field widget that integrates with a `StringNotifier` provider.
///
/// This widget watches a Riverpod provider for its current string value and updates it
/// when the input changes. It supports optional validators, input types, max length,
/// multi-line support, and required-field indication.
///
/// [NotifierT] must extend [StringNotifier], and the provider must match the type
/// `AutoDisposeNotifierProvider<NotifierT, String>`.

class ConsumerTextFormField<NotifierT extends StringNotifier>
    extends ConsumerWidget {
  // provider was generated by @riverpod
  final AutoDisposeNotifierProvider<NotifierT, String> provider;
  final String labelText;
  final String hintText;
  final FormFieldValidator<String>? validator;
  final TextInputType keyboardType;
  final int maxLines;
  final int? maxLength;
  final bool? isRequired;

  const ConsumerTextFormField({
    super.key,
    required this.provider,
    required this.labelText,
    this.validator,
    this.keyboardType = TextInputType.text,
    this.maxLines = 1,
    this.hintText = '',
    this.maxLength,
    this.isRequired = false,
  });

  /// Builds a [TextFormField] that reflects the provider's value and updates it on change.
  ///
  /// Displays a label, optional hint text, character limits, validators,
  /// and a red asterisk if the field is required.
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentValue = ref.watch(provider);

    return TextFormField(
      initialValue: currentValue,
      decoration: InputDecoration(
        border: const OutlineInputBorder(),
        label: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(labelText),
            if (isRequired ?? false)
              const Text(' *', style: TextStyle(color: Colors.red)),
          ],
        ),
        hintText: hintText,
      ),
      keyboardType: keyboardType,
      maxLines: maxLines,
      maxLengthEnforcement: maxLength != null
          ? MaxLengthEnforcement.enforced
          : null,
      maxLength: maxLength,
      validator: validator,
      // Update the providerâ€™s state when the user types new input
      onChanged: (newText) {
        ref.read(provider.notifier).setValue(newText);
      },
    );
  }
}
